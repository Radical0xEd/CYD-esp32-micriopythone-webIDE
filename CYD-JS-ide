#include <WiFi.h>
#include <WebServer.h>
#include <SPIFFS.h>
#include <ArduinoJson.h>
#include <TFT_eSPI.h>

// TFT Display setup
TFT_eSPI tft = TFT_eSPI();

// Web server on port 80
WebServer server(80);

// WiFi AP credentials
const char* ssid = "ESP32-DevConsole";
const char* password = "12345678";

// IP configuration
IPAddress local_ip(192, 168, 1, 1);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 255, 0);

// Storage for JavaScript snippets
String savedScripts[10];
String scriptNames[10];
int scriptCount = 0;

void setup() {
  Serial.begin(115200);

  // Initialize TFT display
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.setTextSize(2);

  // Initialize SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS Mount Failed");
    tft.println("SPIFFS Failed");
    return;
  }

  // Display startup message
  tft.fillScreen(TFT_BLACK);
  tft.setCursor(0, 0);
  tft.println("ESP32 Dev Console");
  tft.println("Starting WiFi AP...");

  // Configure WiFi AP
  WiFi.softAP(ssid, password);
  WiFi.softAPConfig(local_ip, gateway, subnet);
  tft.println("WiFi AP Started");
  tft.print("IP: ");
  tft.println(WiFi.softAPIP());
  tft.println("Connect to:");
  tft.println(ssid);
  tft.println("Password: 12345678");

  // Setup web server routes
  server.on("/", handleRoot);
  server.on("/console", handleConsole);
  server.on("/execute", HTTP_POST, handleExecute);
  server.on("/save", HTTP_POST, handleSave);
  server.on("/load", handleLoad);
  server.on("/scripts", handleScripts);
  server.onNotFound(handleNotFound);
  server.begin();
  Serial.println("HTTP server started");

  // Load saved scripts from SPIFFS
  loadScriptsFromSPIFFS();

  // Add additional routes
  setupAdditionalRoutes();
}

void loop() {
  server.handleClient();

  // Update display with connection count
  static unsigned long lastUpdate = 0;
  if (millis() - lastUpdate > 5000) {
    updateDisplay();
    lastUpdate = millis();
  }

  // Call loop enhancements
  loopEnhancements();
}

void updateDisplay() {
  // Clear bottom area for status updates
  tft.fillRect(0, 200, 320, 40, TFT_BLACK);
  tft.setCursor(0, 200);
  tft.print("Clients: ");
  tft.println(WiFi.softAPgetStationNum());
  tft.print("Uptime: ");
  tft.print(millis() / 1000);
  tft.println("s");
}

void handleRoot() {
  String html = R"(
  <!DOCTYPE html>
  <html>
  <head>
    <title>ESP32 Dev Console</title>
  </head>
  <body>
    <h1>ESP32 Development Console</h1>
    <p>Write and execute JavaScript code</p>
    <textarea id="code" rows="10" cols="50"></textarea>
    <br>
    <button onclick="executeCode()">Execute Code</button>
    <button onclick="clearOutput()">Clear Output</button>
    <button onclick="clearCode()">Clear Code</button>
    <pre id="output"></pre>
    <script>
      function executeCode() {
        const code = document.getElementById('code').value;
        fetch('/execute', {
          method: 'POST',
          body: JSON.stringify({ code }),
          headers: { 'Content-Type': 'application/json' }
        }).then(response => response.text()).then(data => {
          document.getElementById('output').innerText = data;
        });
      }
      function clearOutput() {
        document.getElementById('output').innerText = '';
      }
      function clearCode() {
        document.getElementById('code').value = '';
      }
    </script>
  </body>
  </html>
  )";
  server.send(200, "text/html", html);
}

void handleConsole() {
  server.send(200, "text/plain", "Console endpoint");
}

void handleExecute() {
  if (server.hasArg("plain")) {
    DynamicJsonDocument doc(1024);
    deserializeJson(doc, server.arg("plain"));
    String code = doc["code"];
    Serial.println("Executing code:");
    Serial.println(code);
    // Here you could add ESP32-specific code execution
    // For now, just log to serial
    server.send(200, "text/plain", "Code executed");
  } else {
    server.send(400, "text/plain", "No code provided");
  }
}

void handleSave() {
  if (server.hasArg("plain")) {
    DynamicJsonDocument doc(1024);
    deserializeJson(doc, server.arg("plain"));
    String name = doc["name"];
    String code = doc["code"];
    // Save to array (in a real implementation, save to SPIFFS)
    if (scriptCount < 10) {
      scriptNames[scriptCount] = name;
      savedScripts[scriptCount] = code;
      scriptCount++;
      // Save to SPIFFS file
      File file = SPIFFS.open("/" + name + ".js", "w");
      if (file) {
        file.print(code);
        file.close();
      }
    }
    server.send(200, "text/plain", "Script saved");
  } else {
    server.send(400, "text/plain", "No data provided");
  }
}

void handleLoad() {
  String name = server.arg("name");
  // Load from SPIFFS
  File file = SPIFFS.open("/" + name + ".js", "r");
  if (file) {
    String code = file.readString();
    file.close();
    server.send(200, "text/plain", code);
  } else {
    server.send(404, "text/plain", "Script not found");
  }
}

void handleScripts() {
  DynamicJsonDocument doc(2048);
  JsonArray scripts = doc.createNestedArray("scripts");
  for (int i = 0; i < scriptCount; i++) {
    JsonObject script = scripts.createNestedObject();
    script["name"] = scriptNames[i];
    script["code"] = savedScripts[i];
  }
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleNotFound() {
  server.send(404, "text/plain", "Not found");
}

void loadScriptsFromSPIFFS() {
  Serial.println("Loading scripts from SPIFFS...");
  scriptCount = 0;
  File root = SPIFFS.open("/");
  File file = root.openNextFile();
  while (file && scriptCount < 10) {
    String fileName = file.name();
    if (fileName.endsWith(".js")) {
      // Remove .js extension for display
      String scriptName = fileName.substring(1, fileName.length() - 3);
      scriptNames[scriptCount] = scriptName;
      // Read file content
      savedScripts[scriptCount] = file.readString();
      file.close();
      Serial.print("Loaded script: ");
      Serial.println(scriptName);
      scriptCount++;
    }
    file = root.openNextFile();
  }
  Serial.print("Total scripts loaded: ");
  Serial.println(scriptCount);
  // Update display with script count
  tft.fillRect(0, 160, 320, 20, TFT_BLACK);
  tft.setCursor(0, 160);
  tft.print("Scripts: ");
  tft.println(scriptCount);
}

void formatSPIFFS() {
  Serial.println("Formatting SPIFFS...");
  tft.fillRect(0, 180, 320, 20, TFT_BLACK);
  tft.setCursor(0, 180);
  tft.println("Formatting...");
  SPIFFS.format();
  scriptCount = 0;
  tft.fillRect(0, 180, 320, 20, TFT_BLACK);
  tft.setCursor(0, 180);
  tft.println("Format complete");
}

void listSPIFFSFiles() {
  Serial.println("SPIFFS file listing:");
  File root = SPIFFS.open("/");
  File file = root.openNextFile();
  while (file) {
    Serial.print("FILE: ");
    Serial.print(file.name());
    Serial.print(" SIZE: ");
    Serial.println(file.size());
    file = root.openNextFile();
  }
}

void checkWiFiClients() {
  static int lastClientCount = -1;
  int currentClients = WiFi.softAPgetStationNum();
  if (currentClients != lastClientCount) {
    Serial.print("Client count changed: ");
    Serial.println(currentClients);
    // Update TFT display
    tft.fillRect(200, 200, 120, 20, TFT_BLACK);
    tft.setCursor(200, 200);
    tft.print("Clients: ");
    tft.println(currentClients);
    lastClientCount = currentClients;
  }
}

void displaySystemInfo() {
  tft.fillRect(0, 220, 320, 20, TFT_BLACK);
  tft.setCursor(0, 220);
  tft.print("Free RAM: ");
  tft.print(ESP.getFreeHeap());
  tft.print(" bytes");
}

void handleDeleteScript() {
  String name = server.arg("name");
  String filePath = "/" + name + ".js";
  if (SPIFFS.remove(filePath)) {
    // Remove from memory array
    for (int i = 0; i < scriptCount; i++) {
      if (scriptNames[i] == name) {
        // Shift remaining scripts down
        for (int j = i; j < scriptCount - 1; j++) {
          scriptNames[j] = scriptNames[j + 1];
          savedScripts[j] = savedScripts[j + 1];
        }
        scriptCount--;
        break;
      }
    }
    server.send(200, "text/plain", "Script deleted");
  } else {
    server.send(404, "text/plain", "Script not found");
  }
}

void handleReset() {
  server.send(200, "text/plain", "Restarting ESP32...");
  delay(1000);
  ESP.restart();
}

void handleStatus() {
  DynamicJsonDocument doc(512);
  doc["uptime"] = millis() / 1000;
  doc["freeHeap"] = ESP.getFreeHeap();
  doc["clients"] = WiFi.softAPgetStationNum();
  doc["scripts"] = scriptCount;
  doc["chipModel"] = ESP.getChipModel();
  doc["flashSize"] = ESP.getFlashChipSize();
  String response;
  serializeJson(doc, response);
  server.send(200, "application/json", response);
}

void handleFileUpload() {
  HTTPUpload& upload = server.upload();
  if (upload.status == UPLOAD_FILE_START) {
    String filename = upload.filename;
    if (!filename.startsWith("/")) filename = "/" + filename;
    if (!filename.endsWith(".js")) filename += ".js";
    // Open file for writing
    File file = SPIFFS.open(filename, "w");
    if (!file) {
      Serial.println("Failed to open file for writing");
      return;
    }
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    // Write uploaded data to file
    File file = SPIFFS.open("/" + upload.filename, "a");
    if (file) {
      file.write(upload.buf, upload.currentSize);
      file.close();
    }
  } else if (upload.status == UPLOAD_FILE_END) {
    Serial.printf("Upload complete: %s (%u bytes)\n", upload.filename.c_str(), upload.totalSize);
    loadScriptsFromSPIFFS(); // Reload scripts
  }
}

void setupAdditionalRoutes() {
  server.on("/delete", HTTP_POST, handleDeleteScript);
  server.on("/reset", handleReset);
  server.on("/status", handleStatus);
  server.on("/upload", HTTP_POST, []() {
    server.send(200, "text/plain", "Upload complete");
  }, handleFileUpload);
}

void loopEnhancements() {
  static unsigned long lastSystemUpdate = 0;
  static unsigned long lastClientCheck = 0;

  // Update system info every 10 seconds
  if (millis() - lastSystemUpdate > 10000) {
    displaySystemInfo();
    lastSystemUpdate = millis();
  }

  // Check clients every 2 seconds
  if (millis() - lastClientCheck > 2000) {
    checkWiFiClients();
    lastClientCheck = millis();
  }

  // Handle any serial commands for debugging
  if (Serial.available()) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    if (command == "list") {
      listSPIFFSFiles();
    } else if (command == "format") {
      formatSPIFFS();
    } else if (command == "reload") {
      loadScriptsFromSPIFFS();
    } else if (command == "restart") {
      ESP.restart();
    } else if (command == "status") {
      Serial.printf("Uptime: %lu seconds\n", millis() / 1000);
      Serial.printf("Free heap: %u bytes\n", ESP.getFreeHeap());
      Serial.printf("Connected clients: %d\n", WiFi.softAPgetStationNum());
      Serial.printf("Saved scripts: %d\n", scriptCount);
    }
  }
}


